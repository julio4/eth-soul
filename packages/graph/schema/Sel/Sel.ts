// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
    ethereum,
    JSONValue,
    TypedMap,
    Entity,
    Bytes,
    Address,
    BigInt
} from "@graphprotocol/graph-ts";

export class Approval extends ethereum.Event {
    get params(): Approval__Params {
        return new Approval__Params(this);
    }
}

export class Approval__Params {
    _event: Approval;

    constructor(event: Approval) {
        this._event = event;
    }

    get owner(): Address {
        return this._event.parameters[0].value.toAddress();
    }

    get spender(): Address {
        return this._event.parameters[1].value.toAddress();
    }

    get value(): BigInt {
        return this._event.parameters[2].value.toBigInt();
    }
}

export class OfferCanceled extends ethereum.Event {
    get params(): OfferCanceled__Params {
        return new OfferCanceled__Params(this);
    }
}

export class OfferCanceled__Params {
    _event: OfferCanceled;

    constructor(event: OfferCanceled) {
        this._event = event;
    }

    get offerId(): BigInt {
        return this._event.parameters[0].value.toBigInt();
    }

    get offerer(): Address {
        return this._event.parameters[1].value.toAddress();
    }
}

export class OfferCreated extends ethereum.Event {
    get params(): OfferCreated__Params {
        return new OfferCreated__Params(this);
    }
}

export class OfferCreated__Params {
    _event: OfferCreated;

    constructor(event: OfferCreated) {
        this._event = event;
    }

    get offerId(): BigInt {
        return this._event.parameters[0].value.toBigInt();
    }

    get offerer(): Address {
        return this._event.parameters[1].value.toAddress();
    }

    get tokens(): BigInt {
        return this._event.parameters[2].value.toBigInt();
    }

    get hash(): Array<Bytes> {
        return this._event.parameters[3].value.toBytesArray();
    }
}

export class PropositionAccepted extends ethereum.Event {
    get params(): PropositionAccepted__Params {
        return new PropositionAccepted__Params(this);
    }
}

export class PropositionAccepted__Params {
    _event: PropositionAccepted;

    constructor(event: PropositionAccepted) {
        this._event = event;
    }

    get offerId(): BigInt {
        return this._event.parameters[0].value.toBigInt();
    }

    get offerer(): Address {
        return this._event.parameters[1].value.toAddress();
    }

    get requester(): Address {
        return this._event.parameters[2].value.toAddress();
    }

    get tokens(): BigInt {
        return this._event.parameters[3].value.toBigInt();
    }

    get hash(): Array<Bytes> {
        return this._event.parameters[4].value.toBytesArray();
    }
}

export class PropositionCanceled extends ethereum.Event {
    get params(): PropositionCanceled__Params {
        return new PropositionCanceled__Params(this);
    }
}

export class PropositionCanceled__Params {
    _event: PropositionCanceled;

    constructor(event: PropositionCanceled) {
        this._event = event;
    }

    get offerId(): BigInt {
        return this._event.parameters[0].value.toBigInt();
    }

    get proposer(): Address {
        return this._event.parameters[1].value.toAddress();
    }
}

export class PropositionMade extends ethereum.Event {
    get params(): PropositionMade__Params {
        return new PropositionMade__Params(this);
    }
}

export class PropositionMade__Params {
    _event: PropositionMade;

    constructor(event: PropositionMade) {
        this._event = event;
    }

    get offerId(): BigInt {
        return this._event.parameters[0].value.toBigInt();
    }

    get proposer(): Address {
        return this._event.parameters[1].value.toAddress();
    }

    get tokens(): BigInt {
        return this._event.parameters[2].value.toBigInt();
    }

    get hash(): Array<Bytes> {
        return this._event.parameters[3].value.toBytesArray();
    }
}

export class Transfer extends ethereum.Event {
    get params(): Transfer__Params {
        return new Transfer__Params(this);
    }
}

export class Transfer__Params {
    _event: Transfer;

    constructor(event: Transfer) {
        this._event = event;
    }

    get from(): Address {
        return this._event.parameters[0].value.toAddress();
    }

    get to(): Address {
        return this._event.parameters[1].value.toAddress();
    }

    get value(): BigInt {
        return this._event.parameters[2].value.toBigInt();
    }
}

export class Sel__getOfferResult {
    value0: Array<Bytes>;
    value1: BigInt;
    value2: Address;
    value3: boolean;

    constructor(
        value0: Array<Bytes>,
        value1: BigInt,
        value2: Address,
        value3: boolean
    ) {
        this.value0 = value0;
        this.value1 = value1;
        this.value2 = value2;
        this.value3 = value3;
    }

    toMap(): TypedMap<string, ethereum.Value> {
        let map = new TypedMap<string, ethereum.Value>();
        map.set("value0", ethereum.Value.fromFixedBytesArray(this.value0));
        map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
        map.set("value2", ethereum.Value.fromAddress(this.value2));
        map.set("value3", ethereum.Value.fromBoolean(this.value3));
        return map;
    }

    getValue0(): Array<Bytes> {
        return this.value0;
    }

    getValue1(): BigInt {
        return this.value1;
    }

    getValue2(): Address {
        return this.value2;
    }

    getValue3(): boolean {
        return this.value3;
    }
}

export class Sel extends ethereum.SmartContract {
    static bind(address: Address): Sel {
        return new Sel("Sel", address);
    }

    allowance(owner: Address, spender: Address): BigInt {
        let result = super.call(
            "allowance",
            "allowance(address,address):(uint256)",
            [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(spender)]
        );

        return result[0].toBigInt();
    }

    try_allowance(owner: Address, spender: Address): ethereum.CallResult<BigInt> {
        let result = super.tryCall(
            "allowance",
            "allowance(address,address):(uint256)",
            [ethereum.Value.fromAddress(owner), ethereum.Value.fromAddress(spender)]
        );
        if (result.reverted) {
            return new ethereum.CallResult();
        }
        let value = result.value;
        return ethereum.CallResult.fromValue(value[0].toBigInt());
    }

    approve(spender: Address, amount: BigInt): boolean {
        let result = super.call("approve", "approve(address,uint256):(bool)", [
            ethereum.Value.fromAddress(spender),
            ethereum.Value.fromUnsignedBigInt(amount)
        ]);

        return result[0].toBoolean();
    }

    try_approve(spender: Address, amount: BigInt): ethereum.CallResult<boolean> {
        let result = super.tryCall("approve", "approve(address,uint256):(bool)", [
            ethereum.Value.fromAddress(spender),
            ethereum.Value.fromUnsignedBigInt(amount)
        ]);
        if (result.reverted) {
            return new ethereum.CallResult();
        }
        let value = result.value;
        return ethereum.CallResult.fromValue(value[0].toBoolean());
    }

    balanceOf(account: Address): BigInt {
        let result = super.call("balanceOf", "balanceOf(address):(uint256)", [
            ethereum.Value.fromAddress(account)
        ]);

        return result[0].toBigInt();
    }

    try_balanceOf(account: Address): ethereum.CallResult<BigInt> {
        let result = super.tryCall("balanceOf", "balanceOf(address):(uint256)", [
            ethereum.Value.fromAddress(account)
        ]);
        if (result.reverted) {
            return new ethereum.CallResult();
        }
        let value = result.value;
        return ethereum.CallResult.fromValue(value[0].toBigInt());
    }

    decimals(): i32 {
        let result = super.call("decimals", "decimals():(uint8)", []);

        return result[0].toI32();
    }

    try_decimals(): ethereum.CallResult<i32> {
        let result = super.tryCall("decimals", "decimals():(uint8)", []);
        if (result.reverted) {
            return new ethereum.CallResult();
        }
        let value = result.value;
        return ethereum.CallResult.fromValue(value[0].toI32());
    }

    decreaseAllowance(spender: Address, subtractedValue: BigInt): boolean {
        let result = super.call(
            "decreaseAllowance",
            "decreaseAllowance(address,uint256):(bool)",
            [
                ethereum.Value.fromAddress(spender),
                ethereum.Value.fromUnsignedBigInt(subtractedValue)
            ]
        );

        return result[0].toBoolean();
    }

    try_decreaseAllowance(
        spender: Address,
        subtractedValue: BigInt
    ): ethereum.CallResult<boolean> {
        let result = super.tryCall(
            "decreaseAllowance",
            "decreaseAllowance(address,uint256):(bool)",
            [
                ethereum.Value.fromAddress(spender),
                ethereum.Value.fromUnsignedBigInt(subtractedValue)
            ]
        );
        if (result.reverted) {
            return new ethereum.CallResult();
        }
        let value = result.value;
        return ethereum.CallResult.fromValue(value[0].toBoolean());
    }

    getOffer(_offer: BigInt): Sel__getOfferResult {
        let result = super.call(
            "getOffer",
            "getOffer(uint256):(bytes32[2],uint256,address,bool)",
            [ethereum.Value.fromUnsignedBigInt(_offer)]
        );

        return new Sel__getOfferResult(
            result[0].toBytesArray(),
            result[1].toBigInt(),
            result[2].toAddress(),
            result[3].toBoolean()
        );
    }

    try_getOffer(_offer: BigInt): ethereum.CallResult<Sel__getOfferResult> {
        let result = super.tryCall(
            "getOffer",
            "getOffer(uint256):(bytes32[2],uint256,address,bool)",
            [ethereum.Value.fromUnsignedBigInt(_offer)]
        );
        if (result.reverted) {
            return new ethereum.CallResult();
        }
        let value = result.value;
        return ethereum.CallResult.fromValue(
            new Sel__getOfferResult(
                value[0].toBytesArray(),
                value[1].toBigInt(),
                value[2].toAddress(),
                value[3].toBoolean()
            )
        );
    }

    getProposition(_address: Address): BigInt {
        let result = super.call(
            "getProposition",
            "getProposition(address):(uint256)",
            [ethereum.Value.fromAddress(_address)]
        );

        return result[0].toBigInt();
    }

    try_getProposition(_address: Address): ethereum.CallResult<BigInt> {
        let result = super.tryCall(
            "getProposition",
            "getProposition(address):(uint256)",
            [ethereum.Value.fromAddress(_address)]
        );
        if (result.reverted) {
            return new ethereum.CallResult();
        }
        let value = result.value;
        return ethereum.CallResult.fromValue(value[0].toBigInt());
    }

    getStackedBalance(_address: Address): BigInt {
        let result = super.call(
            "getStackedBalance",
            "getStackedBalance(address):(uint256)",
            [ethereum.Value.fromAddress(_address)]
        );

        return result[0].toBigInt();
    }

    try_getStackedBalance(_address: Address): ethereum.CallResult<BigInt> {
        let result = super.tryCall(
            "getStackedBalance",
            "getStackedBalance(address):(uint256)",
            [ethereum.Value.fromAddress(_address)]
        );
        if (result.reverted) {
            return new ethereum.CallResult();
        }
        let value = result.value;
        return ethereum.CallResult.fromValue(value[0].toBigInt());
    }

    increaseAllowance(spender: Address, addedValue: BigInt): boolean {
        let result = super.call(
            "increaseAllowance",
            "increaseAllowance(address,uint256):(bool)",
            [
                ethereum.Value.fromAddress(spender),
                ethereum.Value.fromUnsignedBigInt(addedValue)
            ]
        );

        return result[0].toBoolean();
    }

    try_increaseAllowance(
        spender: Address,
        addedValue: BigInt
    ): ethereum.CallResult<boolean> {
        let result = super.tryCall(
            "increaseAllowance",
            "increaseAllowance(address,uint256):(bool)",
            [
                ethereum.Value.fromAddress(spender),
                ethereum.Value.fromUnsignedBigInt(addedValue)
            ]
        );
        if (result.reverted) {
            return new ethereum.CallResult();
        }
        let value = result.value;
        return ethereum.CallResult.fromValue(value[0].toBoolean());
    }

    latestOfferId(): BigInt {
        let result = super.call("latestOfferId", "latestOfferId():(uint256)", []);

        return result[0].toBigInt();
    }

    try_latestOfferId(): ethereum.CallResult<BigInt> {
        let result = super.tryCall(
            "latestOfferId",
            "latestOfferId():(uint256)",
            []
        );
        if (result.reverted) {
            return new ethereum.CallResult();
        }
        let value = result.value;
        return ethereum.CallResult.fromValue(value[0].toBigInt());
    }

    name(): string {
        let result = super.call("name", "name():(string)", []);

        return result[0].toString();
    }

    try_name(): ethereum.CallResult<string> {
        let result = super.tryCall("name", "name():(string)", []);
        if (result.reverted) {
            return new ethereum.CallResult();
        }
        let value = result.value;
        return ethereum.CallResult.fromValue(value[0].toString());
    }

    symbol(): string {
        let result = super.call("symbol", "symbol():(string)", []);

        return result[0].toString();
    }

    try_symbol(): ethereum.CallResult<string> {
        let result = super.tryCall("symbol", "symbol():(string)", []);
        if (result.reverted) {
            return new ethereum.CallResult();
        }
        let value = result.value;
        return ethereum.CallResult.fromValue(value[0].toString());
    }

    totalSupply(): BigInt {
        let result = super.call("totalSupply", "totalSupply():(uint256)", []);

        return result[0].toBigInt();
    }

    try_totalSupply(): ethereum.CallResult<BigInt> {
        let result = super.tryCall("totalSupply", "totalSupply():(uint256)", []);
        if (result.reverted) {
            return new ethereum.CallResult();
        }
        let value = result.value;
        return ethereum.CallResult.fromValue(value[0].toBigInt());
    }

    transfer(to: Address, amount: BigInt): boolean {
        let result = super.call("transfer", "transfer(address,uint256):(bool)", [
            ethereum.Value.fromAddress(to),
            ethereum.Value.fromUnsignedBigInt(amount)
        ]);

        return result[0].toBoolean();
    }

    try_transfer(to: Address, amount: BigInt): ethereum.CallResult<boolean> {
        let result = super.tryCall("transfer", "transfer(address,uint256):(bool)", [
            ethereum.Value.fromAddress(to),
            ethereum.Value.fromUnsignedBigInt(amount)
        ]);
        if (result.reverted) {
            return new ethereum.CallResult();
        }
        let value = result.value;
        return ethereum.CallResult.fromValue(value[0].toBoolean());
    }

    transferFrom(from: Address, to: Address, amount: BigInt): boolean {
        let result = super.call(
            "transferFrom",
            "transferFrom(address,address,uint256):(bool)",
            [
                ethereum.Value.fromAddress(from),
                ethereum.Value.fromAddress(to),
                ethereum.Value.fromUnsignedBigInt(amount)
            ]
        );

        return result[0].toBoolean();
    }

    try_transferFrom(
        from: Address,
        to: Address,
        amount: BigInt
    ): ethereum.CallResult<boolean> {
        let result = super.tryCall(
            "transferFrom",
            "transferFrom(address,address,uint256):(bool)",
            [
                ethereum.Value.fromAddress(from),
                ethereum.Value.fromAddress(to),
                ethereum.Value.fromUnsignedBigInt(amount)
            ]
        );
        if (result.reverted) {
            return new ethereum.CallResult();
        }
        let value = result.value;
        return ethereum.CallResult.fromValue(value[0].toBoolean());
    }
}

export class ConstructorCall extends ethereum.Call {
    get inputs(): ConstructorCall__Inputs {
        return new ConstructorCall__Inputs(this);
    }

    get outputs(): ConstructorCall__Outputs {
        return new ConstructorCall__Outputs(this);
    }
}

export class ConstructorCall__Inputs {
    _call: ConstructorCall;

    constructor(call: ConstructorCall) {
        this._call = call;
    }

    get _mintValue(): BigInt {
        return this._call.inputValues[0].value.toBigInt();
    }
}

export class ConstructorCall__Outputs {
    _call: ConstructorCall;

    constructor(call: ConstructorCall) {
        this._call = call;
    }
}

export class AcceptOfferCall extends ethereum.Call {
    get inputs(): AcceptOfferCall__Inputs {
        return new AcceptOfferCall__Inputs(this);
    }

    get outputs(): AcceptOfferCall__Outputs {
        return new AcceptOfferCall__Outputs(this);
    }
}

export class AcceptOfferCall__Inputs {
    _call: AcceptOfferCall;

    constructor(call: AcceptOfferCall) {
        this._call = call;
    }

    get _offerId(): BigInt {
        return this._call.inputValues[0].value.toBigInt();
    }

    get proposer(): Address {
        return this._call.inputValues[1].value.toAddress();
    }
}

export class AcceptOfferCall__Outputs {
    _call: AcceptOfferCall;

    constructor(call: AcceptOfferCall) {
        this._call = call;
    }
}

export class ApproveCall extends ethereum.Call {
    get inputs(): ApproveCall__Inputs {
        return new ApproveCall__Inputs(this);
    }

    get outputs(): ApproveCall__Outputs {
        return new ApproveCall__Outputs(this);
    }
}

export class ApproveCall__Inputs {
    _call: ApproveCall;

    constructor(call: ApproveCall) {
        this._call = call;
    }

    get spender(): Address {
        return this._call.inputValues[0].value.toAddress();
    }

    get amount(): BigInt {
        return this._call.inputValues[1].value.toBigInt();
    }
}

export class ApproveCall__Outputs {
    _call: ApproveCall;

    constructor(call: ApproveCall) {
        this._call = call;
    }

    get value0(): boolean {
        return this._call.outputValues[0].value.toBoolean();
    }
}

export class CancelOfferCall extends ethereum.Call {
    get inputs(): CancelOfferCall__Inputs {
        return new CancelOfferCall__Inputs(this);
    }

    get outputs(): CancelOfferCall__Outputs {
        return new CancelOfferCall__Outputs(this);
    }
}

export class CancelOfferCall__Inputs {
    _call: CancelOfferCall;

    constructor(call: CancelOfferCall) {
        this._call = call;
    }

    get _offerId(): BigInt {
        return this._call.inputValues[0].value.toBigInt();
    }
}

export class CancelOfferCall__Outputs {
    _call: CancelOfferCall;

    constructor(call: CancelOfferCall) {
        this._call = call;
    }
}

export class CancelPropositionCall extends ethereum.Call {
    get inputs(): CancelPropositionCall__Inputs {
        return new CancelPropositionCall__Inputs(this);
    }

    get outputs(): CancelPropositionCall__Outputs {
        return new CancelPropositionCall__Outputs(this);
    }
}

export class CancelPropositionCall__Inputs {
    _call: CancelPropositionCall;

    constructor(call: CancelPropositionCall) {
        this._call = call;
    }
}

export class CancelPropositionCall__Outputs {
    _call: CancelPropositionCall;

    constructor(call: CancelPropositionCall) {
        this._call = call;
    }
}

export class CreateOfferCall extends ethereum.Call {
    get inputs(): CreateOfferCall__Inputs {
        return new CreateOfferCall__Inputs(this);
    }

    get outputs(): CreateOfferCall__Outputs {
        return new CreateOfferCall__Outputs(this);
    }
}

export class CreateOfferCall__Inputs {
    _call: CreateOfferCall;

    constructor(call: CreateOfferCall) {
        this._call = call;
    }

    get _tokens(): BigInt {
        return this._call.inputValues[0].value.toBigInt();
    }

    get _hash(): Array<Bytes> {
        return this._call.inputValues[1].value.toBytesArray();
    }
}

export class CreateOfferCall__Outputs {
    _call: CreateOfferCall;

    constructor(call: CreateOfferCall) {
        this._call = call;
    }
}

export class DecreaseAllowanceCall extends ethereum.Call {
    get inputs(): DecreaseAllowanceCall__Inputs {
        return new DecreaseAllowanceCall__Inputs(this);
    }

    get outputs(): DecreaseAllowanceCall__Outputs {
        return new DecreaseAllowanceCall__Outputs(this);
    }
}

export class DecreaseAllowanceCall__Inputs {
    _call: DecreaseAllowanceCall;

    constructor(call: DecreaseAllowanceCall) {
        this._call = call;
    }

    get spender(): Address {
        return this._call.inputValues[0].value.toAddress();
    }

    get subtractedValue(): BigInt {
        return this._call.inputValues[1].value.toBigInt();
    }
}

export class DecreaseAllowanceCall__Outputs {
    _call: DecreaseAllowanceCall;

    constructor(call: DecreaseAllowanceCall) {
        this._call = call;
    }

    get value0(): boolean {
        return this._call.outputValues[0].value.toBoolean();
    }
}

export class GetFreeTokensCall extends ethereum.Call {
    get inputs(): GetFreeTokensCall__Inputs {
        return new GetFreeTokensCall__Inputs(this);
    }

    get outputs(): GetFreeTokensCall__Outputs {
        return new GetFreeTokensCall__Outputs(this);
    }
}

export class GetFreeTokensCall__Inputs {
    _call: GetFreeTokensCall;

    constructor(call: GetFreeTokensCall) {
        this._call = call;
    }

    get _freeTokens(): BigInt {
        return this._call.inputValues[0].value.toBigInt();
    }
}

export class GetFreeTokensCall__Outputs {
    _call: GetFreeTokensCall;

    constructor(call: GetFreeTokensCall) {
        this._call = call;
    }
}

export class IncreaseAllowanceCall extends ethereum.Call {
    get inputs(): IncreaseAllowanceCall__Inputs {
        return new IncreaseAllowanceCall__Inputs(this);
    }

    get outputs(): IncreaseAllowanceCall__Outputs {
        return new IncreaseAllowanceCall__Outputs(this);
    }
}

export class IncreaseAllowanceCall__Inputs {
    _call: IncreaseAllowanceCall;

    constructor(call: IncreaseAllowanceCall) {
        this._call = call;
    }

    get spender(): Address {
        return this._call.inputValues[0].value.toAddress();
    }

    get addedValue(): BigInt {
        return this._call.inputValues[1].value.toBigInt();
    }
}

export class IncreaseAllowanceCall__Outputs {
    _call: IncreaseAllowanceCall;

    constructor(call: IncreaseAllowanceCall) {
        this._call = call;
    }

    get value0(): boolean {
        return this._call.outputValues[0].value.toBoolean();
    }
}

export class MakePropositionCall extends ethereum.Call {
    get inputs(): MakePropositionCall__Inputs {
        return new MakePropositionCall__Inputs(this);
    }

    get outputs(): MakePropositionCall__Outputs {
        return new MakePropositionCall__Outputs(this);
    }
}

export class MakePropositionCall__Inputs {
    _call: MakePropositionCall;

    constructor(call: MakePropositionCall) {
        this._call = call;
    }

    get _offerId(): BigInt {
        return this._call.inputValues[0].value.toBigInt();
    }
}

export class MakePropositionCall__Outputs {
    _call: MakePropositionCall;

    constructor(call: MakePropositionCall) {
        this._call = call;
    }
}

export class TransferCall extends ethereum.Call {
    get inputs(): TransferCall__Inputs {
        return new TransferCall__Inputs(this);
    }

    get outputs(): TransferCall__Outputs {
        return new TransferCall__Outputs(this);
    }
}

export class TransferCall__Inputs {
    _call: TransferCall;

    constructor(call: TransferCall) {
        this._call = call;
    }

    get to(): Address {
        return this._call.inputValues[0].value.toAddress();
    }

    get amount(): BigInt {
        return this._call.inputValues[1].value.toBigInt();
    }
}

export class TransferCall__Outputs {
    _call: TransferCall;

    constructor(call: TransferCall) {
        this._call = call;
    }

    get value0(): boolean {
        return this._call.outputValues[0].value.toBoolean();
    }
}

export class TransferFromCall extends ethereum.Call {
    get inputs(): TransferFromCall__Inputs {
        return new TransferFromCall__Inputs(this);
    }

    get outputs(): TransferFromCall__Outputs {
        return new TransferFromCall__Outputs(this);
    }
}

export class TransferFromCall__Inputs {
    _call: TransferFromCall;

    constructor(call: TransferFromCall) {
        this._call = call;
    }

    get from(): Address {
        return this._call.inputValues[0].value.toAddress();
    }

    get to(): Address {
        return this._call.inputValues[1].value.toAddress();
    }

    get amount(): BigInt {
        return this._call.inputValues[2].value.toBigInt();
    }
}

export class TransferFromCall__Outputs {
    _call: TransferFromCall;

    constructor(call: TransferFromCall) {
        this._call = call;
    }

    get value0(): boolean {
        return this._call.outputValues[0].value.toBoolean();
    }
}

// export class Offers extends ethereum.Event {
//     get params(): Offers__Params {
//         return new Offers__Params(this);
//     }
// }

// export class Offers__Params {
//     _event: Offers;

//     constructor(event: Offers) {
//         this._event = event;
//     }

//     get offerId(): BigInt {
//         return this._event.parameters[0].value.toBigInt();
//     }

//     get offerer(): Address {
//         return this._event.parameters[1].value.toAddress();
//     }

//     get tokens(): BigInt {
//         return this._event.parameters[2].value.toBigInt();
//     }

//     get hash(): Array<Bytes> {
//         return this._event.parameters[3].value.toBytesArray();
//     }

//     get isActive(): boolean {
//         return this._event.parameters[4].value.toBoolean();
//     }
// }